schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""An object with globally unique ID"""
interface Node {
  """A globally unique identifier"""
  id: ID!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "activity"
"""
type activity implements Node {
  archived: Boolean!
  created_at: timestamptz!
  description: String!
  id: ID!
  rank: Int!
  title: String!
  updated_at: timestamptz!
  user_id: uuid!
}

"""
A Relay connection object on "activity"
"""
type activityConnection {
  edges: [activityEdge!]!
  pageInfo: PageInfo!
}

type activityEdge {
  cursor: String!
  node: activity!
}

"""
Boolean expression to filter rows from the table "activity". All fields are combined with a logical 'AND'.
"""
input activity_bool_exp {
  _and: [activity_bool_exp!]
  _not: activity_bool_exp
  _or: [activity_bool_exp!]
  archived: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  rank: Int_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "activity"
"""
enum activity_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  activity_pkey
}

"""
input type for incrementing numeric columns in table "activity"
"""
input activity_inc_input {
  rank: Int
}

"""
input type for inserting data into table "activity"
"""
input activity_insert_input {
  archived: Boolean
  created_at: timestamptz
  description: String
  id: uuid
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "activity"
"""
type activity_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [activity!]!
}

"""
on_conflict condition type for table "activity"
"""
input activity_on_conflict {
  constraint: activity_constraint!
  update_columns: [activity_update_column!]! = []
  where: activity_bool_exp
}

"""Ordering options when selecting data from "activity"."""
input activity_order_by {
  archived: order_by
  created_at: order_by
  description: order_by
  id: order_by
  rank: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: activity"""
input activity_pk_columns_input {
  id: uuid!
}

"""
select columns of table "activity"
"""
enum activity_select_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  rank

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "activity"
"""
input activity_set_input {
  archived: Boolean
  created_at: timestamptz
  description: String
  id: uuid
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "activity"
"""
enum activity_update_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  rank

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id
}

input activity_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: activity_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: activity_set_input
  where: activity_bool_exp!
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "enckey"
"""
type enckey implements Node {
  created_at: timestamptz!
  id: ID!
  key: String!
  salt: String!
}

"""
A Relay connection object on "enckey"
"""
type enckeyConnection {
  edges: [enckeyEdge!]!
  pageInfo: PageInfo!
}

type enckeyEdge {
  cursor: String!
  node: enckey!
}

"""
Boolean expression to filter rows from the table "enckey". All fields are combined with a logical 'AND'.
"""
input enckey_bool_exp {
  _and: [enckey_bool_exp!]
  _not: enckey_bool_exp
  _or: [enckey_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  key: String_comparison_exp
  salt: String_comparison_exp
}

"""
unique or primary key constraints on table "enckey"
"""
enum enckey_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  keypair_pkey
}

"""
input type for inserting data into table "enckey"
"""
input enckey_insert_input {
  created_at: timestamptz
  id: uuid
  key: String
  salt: String
}

"""
response of any mutation on the table "enckey"
"""
type enckey_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [enckey!]!
}

"""
on_conflict condition type for table "enckey"
"""
input enckey_on_conflict {
  constraint: enckey_constraint!
  update_columns: [enckey_update_column!]! = []
  where: enckey_bool_exp
}

"""Ordering options when selecting data from "enckey"."""
input enckey_order_by {
  created_at: order_by
  id: order_by
  key: order_by
  salt: order_by
}

"""primary key columns input for table: enckey"""
input enckey_pk_columns_input {
  id: uuid!
}

"""
select columns of table "enckey"
"""
enum enckey_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  salt
}

"""
input type for updating data in table "enckey"
"""
input enckey_set_input {
  created_at: timestamptz
  id: uuid
  key: String
  salt: String
}

"""
update columns of table "enckey"
"""
enum enckey_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  key

  """column name"""
  salt
}

input enckey_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: enckey_set_input
  where: enckey_bool_exp!
}

"""
columns and relationships of "file_data"
"""
type file_data implements Node {
  created_at: timestamptz!
  id: ID!

  """An object relationship"""
  note: note!
  note_id: uuid!
  path: String!
  title: String!
  updated_at: timestamptz!
}

"""
A Relay connection object on "file_data"
"""
type file_dataConnection {
  edges: [file_dataEdge!]!
  pageInfo: PageInfo!
}

type file_dataEdge {
  cursor: String!
  node: file_data!
}

"""
Boolean expression to filter rows from the table "file_data". All fields are combined with a logical 'AND'.
"""
input file_data_bool_exp {
  _and: [file_data_bool_exp!]
  _not: file_data_bool_exp
  _or: [file_data_bool_exp!]
  created_at: timestamptz_comparison_exp
  note: note_bool_exp
  note_id: uuid_comparison_exp
  path: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "file_data"
"""
enum file_data_constraint {
  """
  unique or primary key constraint on columns "note_id"
  """
  file_data_pkey
}

"""
input type for inserting data into table "file_data"
"""
input file_data_insert_input {
  created_at: timestamptz
  note: note_obj_rel_insert_input
  note_id: uuid
  path: String
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "file_data"
"""
type file_data_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [file_data!]!
}

"""
input type for inserting object relation for remote table "file_data"
"""
input file_data_obj_rel_insert_input {
  data: file_data_insert_input!

  """upsert condition"""
  on_conflict: file_data_on_conflict
}

"""
on_conflict condition type for table "file_data"
"""
input file_data_on_conflict {
  constraint: file_data_constraint!
  update_columns: [file_data_update_column!]! = []
  where: file_data_bool_exp
}

"""Ordering options when selecting data from "file_data"."""
input file_data_order_by {
  created_at: order_by
  note: note_order_by
  note_id: order_by
  path: order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: file_data"""
input file_data_pk_columns_input {
  note_id: uuid!
}

"""
select columns of table "file_data"
"""
enum file_data_select_column {
  """column name"""
  created_at

  """column name"""
  note_id

  """column name"""
  path

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "file_data"
"""
input file_data_set_input {
  created_at: timestamptz
  note_id: uuid
  path: String
  title: String
  updated_at: timestamptz
}

"""
update columns of table "file_data"
"""
enum file_data_update_column {
  """column name"""
  created_at

  """column name"""
  note_id

  """column name"""
  path

  """column name"""
  title

  """column name"""
  updated_at
}

input file_data_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: file_data_set_input
  where: file_data_bool_exp!
}

"""
columns and relationships of "goal"
"""
type goal implements Node {
  archived: Boolean!
  created_at: timestamptz
  description: String!
  id: ID!
  progress: Int!
  rank: Int!
  status: status_simple_enum!
  title: String!
  updated_at: timestamptz
  user_id: uuid!
}

"""
A Relay connection object on "goal"
"""
type goalConnection {
  edges: [goalEdge!]!
  pageInfo: PageInfo!
}

type goalEdge {
  cursor: String!
  node: goal!
}

"""
aggregated selection of "goal"
"""
type goal_aggregate {
  aggregate: goal_aggregate_fields
  nodes: [goal!]!
}

"""
aggregate fields of "goal"
"""
type goal_aggregate_fields {
  avg: goal_avg_fields
  count(columns: [goal_select_column!], distinct: Boolean): Int!
  max: goal_max_fields
  min: goal_min_fields
  stddev: goal_stddev_fields
  stddev_pop: goal_stddev_pop_fields
  stddev_samp: goal_stddev_samp_fields
  sum: goal_sum_fields
  var_pop: goal_var_pop_fields
  var_samp: goal_var_samp_fields
  variance: goal_variance_fields
}

"""
order by aggregate values of table "goal"
"""
input goal_aggregate_order_by {
  avg: goal_avg_order_by
  count: order_by
  max: goal_max_order_by
  min: goal_min_order_by
  stddev: goal_stddev_order_by
  stddev_pop: goal_stddev_pop_order_by
  stddev_samp: goal_stddev_samp_order_by
  sum: goal_sum_order_by
  var_pop: goal_var_pop_order_by
  var_samp: goal_var_samp_order_by
  variance: goal_variance_order_by
}

"""
input type for inserting array relation for remote table "goal"
"""
input goal_arr_rel_insert_input {
  data: [goal_insert_input!]!

  """upsert condition"""
  on_conflict: goal_on_conflict
}

"""aggregate avg on columns"""
type goal_avg_fields {
  progress: Float
  rank: Float
}

"""
order by avg() on columns of table "goal"
"""
input goal_avg_order_by {
  progress: order_by
  rank: order_by
}

"""
Boolean expression to filter rows from the table "goal". All fields are combined with a logical 'AND'.
"""
input goal_bool_exp {
  _and: [goal_bool_exp!]
  _not: goal_bool_exp
  _or: [goal_bool_exp!]
  archived: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  progress: Int_comparison_exp
  rank: Int_comparison_exp
  status: status_simple_enum_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "goal"
"""
enum goal_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  goal_pkey
}

"""
input type for incrementing numeric columns in table "goal"
"""
input goal_inc_input {
  progress: Int
  rank: Int
}

"""
input type for inserting data into table "goal"
"""
input goal_insert_input {
  archived: Boolean
  created_at: timestamptz
  description: String
  id: uuid
  progress: Int
  rank: Int
  status: status_simple_enum
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type goal_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  progress: Int
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "goal"
"""
input goal_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  progress: order_by
  rank: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type goal_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  progress: Int
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "goal"
"""
input goal_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  progress: order_by
  rank: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "goal"
"""
type goal_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [goal!]!
}

"""
input type for inserting object relation for remote table "goal"
"""
input goal_obj_rel_insert_input {
  data: goal_insert_input!

  """upsert condition"""
  on_conflict: goal_on_conflict
}

"""
on_conflict condition type for table "goal"
"""
input goal_on_conflict {
  constraint: goal_constraint!
  update_columns: [goal_update_column!]! = []
  where: goal_bool_exp
}

"""Ordering options when selecting data from "goal"."""
input goal_order_by {
  archived: order_by
  created_at: order_by
  description: order_by
  id: order_by
  progress: order_by
  rank: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: goal"""
input goal_pk_columns_input {
  id: uuid!
}

"""
select columns of table "goal"
"""
enum goal_select_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  progress

  """column name"""
  rank

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "goal"
"""
input goal_set_input {
  archived: Boolean
  created_at: timestamptz
  description: String
  id: uuid
  progress: Int
  rank: Int
  status: status_simple_enum
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type goal_stddev_fields {
  progress: Float
  rank: Float
}

"""
order by stddev() on columns of table "goal"
"""
input goal_stddev_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate stddev_pop on columns"""
type goal_stddev_pop_fields {
  progress: Float
  rank: Float
}

"""
order by stddev_pop() on columns of table "goal"
"""
input goal_stddev_pop_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate stddev_samp on columns"""
type goal_stddev_samp_fields {
  progress: Float
  rank: Float
}

"""
order by stddev_samp() on columns of table "goal"
"""
input goal_stddev_samp_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate sum on columns"""
type goal_sum_fields {
  progress: Int
  rank: Int
}

"""
order by sum() on columns of table "goal"
"""
input goal_sum_order_by {
  progress: order_by
  rank: order_by
}

"""
update columns of table "goal"
"""
enum goal_update_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  progress

  """column name"""
  rank

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id
}

input goal_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: goal_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: goal_set_input
  where: goal_bool_exp!
}

"""aggregate var_pop on columns"""
type goal_var_pop_fields {
  progress: Float
  rank: Float
}

"""
order by var_pop() on columns of table "goal"
"""
input goal_var_pop_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate var_samp on columns"""
type goal_var_samp_fields {
  progress: Float
  rank: Float
}

"""
order by var_samp() on columns of table "goal"
"""
input goal_var_samp_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate variance on columns"""
type goal_variance_fields {
  progress: Float
  rank: Float
}

"""
order by variance() on columns of table "goal"
"""
input goal_variance_order_by {
  progress: order_by
  rank: order_by
}

"""
columns and relationships of "memouser"
"""
type memouser implements Node {
  auth_id: uuid!
  created_at: timestamptz!

  """An array relationship"""
  goals(
    """distinct select on columns"""
    distinct_on: [goal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [goal_order_by!]

    """filter the rows returned"""
    where: goal_bool_exp
  ): [goal!]!

  """An aggregate relationship"""
  goals_aggregate(
    """distinct select on columns"""
    distinct_on: [goal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [goal_order_by!]

    """filter the rows returned"""
    where: goal_bool_exp
  ): goal_aggregate!

  """An array relationship connection"""
  goals_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [goal_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [goal_order_by!]

    """filter the rows returned"""
    where: goal_bool_exp
  ): goalConnection!
  id: ID!

  """An object relationship"""
  invited_by: memouser
  invited_by_id: uuid
  level: Int!

  """An array relationship"""
  notes(
    """distinct select on columns"""
    distinct_on: [note_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [note_order_by!]

    """filter the rows returned"""
    where: note_bool_exp
  ): [note!]!

  """An aggregate relationship"""
  notes_aggregate(
    """distinct select on columns"""
    distinct_on: [note_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [note_order_by!]

    """filter the rows returned"""
    where: note_bool_exp
  ): note_aggregate!

  """An array relationship connection"""
  notes_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [note_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [note_order_by!]

    """filter the rows returned"""
    where: note_bool_exp
  ): noteConnection!

  """An array relationship"""
  todos(
    """distinct select on columns"""
    distinct_on: [todo_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [todo_order_by!]

    """filter the rows returned"""
    where: todo_bool_exp
  ): [todo!]!

  """An aggregate relationship"""
  todos_aggregate(
    """distinct select on columns"""
    distinct_on: [todo_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [todo_order_by!]

    """filter the rows returned"""
    where: todo_bool_exp
  ): todo_aggregate!

  """An array relationship connection"""
  todos_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [todo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [todo_order_by!]

    """filter the rows returned"""
    where: todo_bool_exp
  ): todoConnection!
}

"""
A Relay connection object on "memouser"
"""
type memouserConnection {
  edges: [memouserEdge!]!
  pageInfo: PageInfo!
}

type memouserEdge {
  cursor: String!
  node: memouser!
}

"""
Boolean expression to filter rows from the table "memouser". All fields are combined with a logical 'AND'.
"""
input memouser_bool_exp {
  _and: [memouser_bool_exp!]
  _not: memouser_bool_exp
  _or: [memouser_bool_exp!]
  auth_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  goals: goal_bool_exp
  id: uuid_comparison_exp
  invited_by: memouser_bool_exp
  invited_by_id: uuid_comparison_exp
  level: Int_comparison_exp
  notes: note_bool_exp
  todos: todo_bool_exp
}

"""
unique or primary key constraints on table "memouser"
"""
enum memouser_constraint {
  """
  unique or primary key constraint on columns "auth_id"
  """
  memouser_auth_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_pkey
}

"""
input type for incrementing numeric columns in table "memouser"
"""
input memouser_inc_input {
  level: Int
}

"""
input type for inserting data into table "memouser"
"""
input memouser_insert_input {
  auth_id: uuid
  created_at: timestamptz
  goals: goal_arr_rel_insert_input
  id: uuid
  invited_by: memouser_obj_rel_insert_input
  invited_by_id: uuid
  level: Int
  notes: note_arr_rel_insert_input
  todos: todo_arr_rel_insert_input
}

"""
response of any mutation on the table "memouser"
"""
type memouser_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [memouser!]!
}

"""
input type for inserting object relation for remote table "memouser"
"""
input memouser_obj_rel_insert_input {
  data: memouser_insert_input!

  """upsert condition"""
  on_conflict: memouser_on_conflict
}

"""
on_conflict condition type for table "memouser"
"""
input memouser_on_conflict {
  constraint: memouser_constraint!
  update_columns: [memouser_update_column!]! = []
  where: memouser_bool_exp
}

"""Ordering options when selecting data from "memouser"."""
input memouser_order_by {
  auth_id: order_by
  created_at: order_by
  goals_aggregate: goal_aggregate_order_by
  id: order_by
  invited_by: memouser_order_by
  invited_by_id: order_by
  level: order_by
  notes_aggregate: note_aggregate_order_by
  todos_aggregate: todo_aggregate_order_by
}

"""primary key columns input for table: memouser"""
input memouser_pk_columns_input {
  id: uuid!
}

"""
select columns of table "memouser"
"""
enum memouser_select_column {
  """column name"""
  auth_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  invited_by_id

  """column name"""
  level
}

"""
input type for updating data in table "memouser"
"""
input memouser_set_input {
  auth_id: uuid
  created_at: timestamptz
  id: uuid
  invited_by_id: uuid
  level: Int
}

"""
update columns of table "memouser"
"""
enum memouser_update_column {
  """column name"""
  auth_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  invited_by_id

  """column name"""
  level
}

input memouser_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: memouser_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: memouser_set_input
  where: memouser_bool_exp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "activity"
  """
  delete_activity(
    """filter the rows which have to be deleted"""
    where: activity_bool_exp!
  ): activity_mutation_response

  """
  delete single row from the table: "activity"
  """
  delete_activity_by_pk(id: uuid!): activity

  """
  delete data from the table: "enckey"
  """
  delete_enckey(
    """filter the rows which have to be deleted"""
    where: enckey_bool_exp!
  ): enckey_mutation_response

  """
  delete single row from the table: "enckey"
  """
  delete_enckey_by_pk(id: uuid!): enckey

  """
  delete data from the table: "file_data"
  """
  delete_file_data(
    """filter the rows which have to be deleted"""
    where: file_data_bool_exp!
  ): file_data_mutation_response

  """
  delete single row from the table: "file_data"
  """
  delete_file_data_by_pk(note_id: uuid!): file_data

  """
  delete data from the table: "goal"
  """
  delete_goal(
    """filter the rows which have to be deleted"""
    where: goal_bool_exp!
  ): goal_mutation_response

  """
  delete single row from the table: "goal"
  """
  delete_goal_by_pk(id: uuid!): goal

  """
  delete data from the table: "memouser"
  """
  delete_memouser(
    """filter the rows which have to be deleted"""
    where: memouser_bool_exp!
  ): memouser_mutation_response

  """
  delete single row from the table: "memouser"
  """
  delete_memouser_by_pk(id: uuid!): memouser

  """
  delete data from the table: "note"
  """
  delete_note(
    """filter the rows which have to be deleted"""
    where: note_bool_exp!
  ): note_mutation_response

  """
  delete single row from the table: "note"
  """
  delete_note_by_pk(id: uuid!): note

  """
  delete data from the table: "note_goal"
  """
  delete_note_goal(
    """filter the rows which have to be deleted"""
    where: note_goal_bool_exp!
  ): note_goal_mutation_response

  """
  delete single row from the table: "note_goal"
  """
  delete_note_goal_by_pk(id: uuid!): note_goal

  """
  delete data from the table: "status_simple"
  """
  delete_status_simple(
    """filter the rows which have to be deleted"""
    where: status_simple_bool_exp!
  ): status_simple_mutation_response

  """
  delete single row from the table: "status_simple"
  """
  delete_status_simple_by_pk(value: String!): status_simple

  """
  delete data from the table: "todo"
  """
  delete_todo(
    """filter the rows which have to be deleted"""
    where: todo_bool_exp!
  ): todo_mutation_response

  """
  delete single row from the table: "todo"
  """
  delete_todo_by_pk(id: uuid!): todo

  """
  insert data into the table: "activity"
  """
  insert_activity(
    """the rows to be inserted"""
    objects: [activity_insert_input!]!

    """upsert condition"""
    on_conflict: activity_on_conflict
  ): activity_mutation_response

  """
  insert a single row into the table: "activity"
  """
  insert_activity_one(
    """the row to be inserted"""
    object: activity_insert_input!

    """upsert condition"""
    on_conflict: activity_on_conflict
  ): activity

  """
  insert data into the table: "enckey"
  """
  insert_enckey(
    """the rows to be inserted"""
    objects: [enckey_insert_input!]!

    """upsert condition"""
    on_conflict: enckey_on_conflict
  ): enckey_mutation_response

  """
  insert a single row into the table: "enckey"
  """
  insert_enckey_one(
    """the row to be inserted"""
    object: enckey_insert_input!

    """upsert condition"""
    on_conflict: enckey_on_conflict
  ): enckey

  """
  insert data into the table: "file_data"
  """
  insert_file_data(
    """the rows to be inserted"""
    objects: [file_data_insert_input!]!

    """upsert condition"""
    on_conflict: file_data_on_conflict
  ): file_data_mutation_response

  """
  insert a single row into the table: "file_data"
  """
  insert_file_data_one(
    """the row to be inserted"""
    object: file_data_insert_input!

    """upsert condition"""
    on_conflict: file_data_on_conflict
  ): file_data

  """
  insert data into the table: "goal"
  """
  insert_goal(
    """the rows to be inserted"""
    objects: [goal_insert_input!]!

    """upsert condition"""
    on_conflict: goal_on_conflict
  ): goal_mutation_response

  """
  insert a single row into the table: "goal"
  """
  insert_goal_one(
    """the row to be inserted"""
    object: goal_insert_input!

    """upsert condition"""
    on_conflict: goal_on_conflict
  ): goal

  """
  insert data into the table: "memouser"
  """
  insert_memouser(
    """the rows to be inserted"""
    objects: [memouser_insert_input!]!

    """upsert condition"""
    on_conflict: memouser_on_conflict
  ): memouser_mutation_response

  """
  insert a single row into the table: "memouser"
  """
  insert_memouser_one(
    """the row to be inserted"""
    object: memouser_insert_input!

    """upsert condition"""
    on_conflict: memouser_on_conflict
  ): memouser

  """
  insert data into the table: "note"
  """
  insert_note(
    """the rows to be inserted"""
    objects: [note_insert_input!]!

    """upsert condition"""
    on_conflict: note_on_conflict
  ): note_mutation_response

  """
  insert data into the table: "note_goal"
  """
  insert_note_goal(
    """the rows to be inserted"""
    objects: [note_goal_insert_input!]!

    """upsert condition"""
    on_conflict: note_goal_on_conflict
  ): note_goal_mutation_response

  """
  insert a single row into the table: "note_goal"
  """
  insert_note_goal_one(
    """the row to be inserted"""
    object: note_goal_insert_input!

    """upsert condition"""
    on_conflict: note_goal_on_conflict
  ): note_goal

  """
  insert a single row into the table: "note"
  """
  insert_note_one(
    """the row to be inserted"""
    object: note_insert_input!

    """upsert condition"""
    on_conflict: note_on_conflict
  ): note

  """
  insert data into the table: "status_simple"
  """
  insert_status_simple(
    """the rows to be inserted"""
    objects: [status_simple_insert_input!]!

    """upsert condition"""
    on_conflict: status_simple_on_conflict
  ): status_simple_mutation_response

  """
  insert a single row into the table: "status_simple"
  """
  insert_status_simple_one(
    """the row to be inserted"""
    object: status_simple_insert_input!

    """upsert condition"""
    on_conflict: status_simple_on_conflict
  ): status_simple

  """
  insert data into the table: "todo"
  """
  insert_todo(
    """the rows to be inserted"""
    objects: [todo_insert_input!]!

    """upsert condition"""
    on_conflict: todo_on_conflict
  ): todo_mutation_response

  """
  insert a single row into the table: "todo"
  """
  insert_todo_one(
    """the row to be inserted"""
    object: todo_insert_input!

    """upsert condition"""
    on_conflict: todo_on_conflict
  ): todo

  """
  update data of the table: "activity"
  """
  update_activity(
    """increments the numeric columns with given value of the filtered values"""
    _inc: activity_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: activity_set_input

    """filter the rows which have to be updated"""
    where: activity_bool_exp!
  ): activity_mutation_response

  """
  update single row of the table: "activity"
  """
  update_activity_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: activity_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: activity_set_input
    pk_columns: activity_pk_columns_input!
  ): activity

  """
  update multiples rows of table: "activity"
  """
  update_activity_many(
    """updates to execute, in order"""
    updates: [activity_updates!]!
  ): [activity_mutation_response]

  """
  update data of the table: "enckey"
  """
  update_enckey(
    """sets the columns of the filtered rows to the given values"""
    _set: enckey_set_input

    """filter the rows which have to be updated"""
    where: enckey_bool_exp!
  ): enckey_mutation_response

  """
  update single row of the table: "enckey"
  """
  update_enckey_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: enckey_set_input
    pk_columns: enckey_pk_columns_input!
  ): enckey

  """
  update multiples rows of table: "enckey"
  """
  update_enckey_many(
    """updates to execute, in order"""
    updates: [enckey_updates!]!
  ): [enckey_mutation_response]

  """
  update data of the table: "file_data"
  """
  update_file_data(
    """sets the columns of the filtered rows to the given values"""
    _set: file_data_set_input

    """filter the rows which have to be updated"""
    where: file_data_bool_exp!
  ): file_data_mutation_response

  """
  update single row of the table: "file_data"
  """
  update_file_data_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: file_data_set_input
    pk_columns: file_data_pk_columns_input!
  ): file_data

  """
  update multiples rows of table: "file_data"
  """
  update_file_data_many(
    """updates to execute, in order"""
    updates: [file_data_updates!]!
  ): [file_data_mutation_response]

  """
  update data of the table: "goal"
  """
  update_goal(
    """increments the numeric columns with given value of the filtered values"""
    _inc: goal_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: goal_set_input

    """filter the rows which have to be updated"""
    where: goal_bool_exp!
  ): goal_mutation_response

  """
  update single row of the table: "goal"
  """
  update_goal_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: goal_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: goal_set_input
    pk_columns: goal_pk_columns_input!
  ): goal

  """
  update multiples rows of table: "goal"
  """
  update_goal_many(
    """updates to execute, in order"""
    updates: [goal_updates!]!
  ): [goal_mutation_response]

  """
  update data of the table: "memouser"
  """
  update_memouser(
    """increments the numeric columns with given value of the filtered values"""
    _inc: memouser_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: memouser_set_input

    """filter the rows which have to be updated"""
    where: memouser_bool_exp!
  ): memouser_mutation_response

  """
  update single row of the table: "memouser"
  """
  update_memouser_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: memouser_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: memouser_set_input
    pk_columns: memouser_pk_columns_input!
  ): memouser

  """
  update multiples rows of table: "memouser"
  """
  update_memouser_many(
    """updates to execute, in order"""
    updates: [memouser_updates!]!
  ): [memouser_mutation_response]

  """
  update data of the table: "note"
  """
  update_note(
    """increments the numeric columns with given value of the filtered values"""
    _inc: note_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: note_set_input

    """filter the rows which have to be updated"""
    where: note_bool_exp!
  ): note_mutation_response

  """
  update single row of the table: "note"
  """
  update_note_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: note_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: note_set_input
    pk_columns: note_pk_columns_input!
  ): note

  """
  update data of the table: "note_goal"
  """
  update_note_goal(
    """sets the columns of the filtered rows to the given values"""
    _set: note_goal_set_input

    """filter the rows which have to be updated"""
    where: note_goal_bool_exp!
  ): note_goal_mutation_response

  """
  update single row of the table: "note_goal"
  """
  update_note_goal_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: note_goal_set_input
    pk_columns: note_goal_pk_columns_input!
  ): note_goal

  """
  update multiples rows of table: "note_goal"
  """
  update_note_goal_many(
    """updates to execute, in order"""
    updates: [note_goal_updates!]!
  ): [note_goal_mutation_response]

  """
  update multiples rows of table: "note"
  """
  update_note_many(
    """updates to execute, in order"""
    updates: [note_updates!]!
  ): [note_mutation_response]

  """
  update data of the table: "status_simple"
  """
  update_status_simple(
    """sets the columns of the filtered rows to the given values"""
    _set: status_simple_set_input

    """filter the rows which have to be updated"""
    where: status_simple_bool_exp!
  ): status_simple_mutation_response

  """
  update single row of the table: "status_simple"
  """
  update_status_simple_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: status_simple_set_input
    pk_columns: status_simple_pk_columns_input!
  ): status_simple

  """
  update multiples rows of table: "status_simple"
  """
  update_status_simple_many(
    """updates to execute, in order"""
    updates: [status_simple_updates!]!
  ): [status_simple_mutation_response]

  """
  update data of the table: "todo"
  """
  update_todo(
    """increments the numeric columns with given value of the filtered values"""
    _inc: todo_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: todo_set_input

    """filter the rows which have to be updated"""
    where: todo_bool_exp!
  ): todo_mutation_response

  """
  update single row of the table: "todo"
  """
  update_todo_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: todo_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: todo_set_input
    pk_columns: todo_pk_columns_input!
  ): todo

  """
  update multiples rows of table: "todo"
  """
  update_todo_many(
    """updates to execute, in order"""
    updates: [todo_updates!]!
  ): [todo_mutation_response]
}

"""
columns and relationships of "note"
"""
type note implements Node {
  archived: Boolean!
  body: String!
  created_at: timestamptz!
  date: date!

  """An object relationship"""
  file: file_data

  """An array relationship"""
  goals(
    """distinct select on columns"""
    distinct_on: [note_goal_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [note_goal_view_order_by!]

    """filter the rows returned"""
    where: note_goal_view_bool_exp
  ): [note_goal_view!]!

  """An aggregate relationship"""
  goals_aggregate(
    """distinct select on columns"""
    distinct_on: [note_goal_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [note_goal_view_order_by!]

    """filter the rows returned"""
    where: note_goal_view_bool_exp
  ): note_goal_view_aggregate!
  id: ID!

  """An array relationship"""
  note_goal(
    """distinct select on columns"""
    distinct_on: [note_goal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [note_goal_order_by!]

    """filter the rows returned"""
    where: note_goal_bool_exp
  ): [note_goal!]!

  """An aggregate relationship"""
  note_goal_aggregate(
    """distinct select on columns"""
    distinct_on: [note_goal_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [note_goal_order_by!]

    """filter the rows returned"""
    where: note_goal_bool_exp
  ): note_goal_aggregate!

  """An array relationship connection"""
  note_goal_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [note_goal_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [note_goal_order_by!]

    """filter the rows returned"""
    where: note_goal_bool_exp
  ): note_goalConnection!
  pinned: Boolean!
  title: String!
  updated_at: timestamptz
  user_id: uuid!
  version: Int!
}

"""
A Relay connection object on "note"
"""
type noteConnection {
  edges: [noteEdge!]!
  pageInfo: PageInfo!
}

type noteEdge {
  cursor: String!
  node: note!
}

"""
aggregated selection of "note"
"""
type note_aggregate {
  aggregate: note_aggregate_fields
  nodes: [note!]!
}

"""
aggregate fields of "note"
"""
type note_aggregate_fields {
  avg: note_avg_fields
  count(columns: [note_select_column!], distinct: Boolean): Int!
  max: note_max_fields
  min: note_min_fields
  stddev: note_stddev_fields
  stddev_pop: note_stddev_pop_fields
  stddev_samp: note_stddev_samp_fields
  sum: note_sum_fields
  var_pop: note_var_pop_fields
  var_samp: note_var_samp_fields
  variance: note_variance_fields
}

"""
order by aggregate values of table "note"
"""
input note_aggregate_order_by {
  avg: note_avg_order_by
  count: order_by
  max: note_max_order_by
  min: note_min_order_by
  stddev: note_stddev_order_by
  stddev_pop: note_stddev_pop_order_by
  stddev_samp: note_stddev_samp_order_by
  sum: note_sum_order_by
  var_pop: note_var_pop_order_by
  var_samp: note_var_samp_order_by
  variance: note_variance_order_by
}

"""
input type for inserting array relation for remote table "note"
"""
input note_arr_rel_insert_input {
  data: [note_insert_input!]!

  """upsert condition"""
  on_conflict: note_on_conflict
}

"""aggregate avg on columns"""
type note_avg_fields {
  version: Float
}

"""
order by avg() on columns of table "note"
"""
input note_avg_order_by {
  version: order_by
}

"""
Boolean expression to filter rows from the table "note". All fields are combined with a logical 'AND'.
"""
input note_bool_exp {
  _and: [note_bool_exp!]
  _not: note_bool_exp
  _or: [note_bool_exp!]
  archived: Boolean_comparison_exp
  body: String_comparison_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  file: file_data_bool_exp
  goals: note_goal_view_bool_exp
  id: uuid_comparison_exp
  note_goal: note_goal_bool_exp
  pinned: Boolean_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "note"
"""
enum note_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  note_pkey
}

"""
columns and relationships of "note_goal"
"""
type note_goal implements Node {
  """An object relationship"""
  goal: goal!
  goal_id: uuid!
  id: ID!

  """An object relationship"""
  note: note!
  note_id: uuid!
}

"""
A Relay connection object on "note_goal"
"""
type note_goalConnection {
  edges: [note_goalEdge!]!
  pageInfo: PageInfo!
}

type note_goalEdge {
  cursor: String!
  node: note_goal!
}

"""
aggregated selection of "note_goal"
"""
type note_goal_aggregate {
  aggregate: note_goal_aggregate_fields
  nodes: [note_goal!]!
}

"""
aggregate fields of "note_goal"
"""
type note_goal_aggregate_fields {
  count(columns: [note_goal_select_column!], distinct: Boolean): Int!
  max: note_goal_max_fields
  min: note_goal_min_fields
}

"""
order by aggregate values of table "note_goal"
"""
input note_goal_aggregate_order_by {
  count: order_by
  max: note_goal_max_order_by
  min: note_goal_min_order_by
}

"""
input type for inserting array relation for remote table "note_goal"
"""
input note_goal_arr_rel_insert_input {
  data: [note_goal_insert_input!]!

  """upsert condition"""
  on_conflict: note_goal_on_conflict
}

"""
Boolean expression to filter rows from the table "note_goal". All fields are combined with a logical 'AND'.
"""
input note_goal_bool_exp {
  _and: [note_goal_bool_exp!]
  _not: note_goal_bool_exp
  _or: [note_goal_bool_exp!]
  goal: goal_bool_exp
  goal_id: uuid_comparison_exp
  id: uuid_comparison_exp
  note: note_bool_exp
  note_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "note_goal"
"""
enum note_goal_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  note_activity_pkey

  """
  unique or primary key constraint on columns "note_id", "goal_id"
  """
  note_goal_note_id_goal_id_key
}

"""
input type for inserting data into table "note_goal"
"""
input note_goal_insert_input {
  goal: goal_obj_rel_insert_input
  goal_id: uuid
  id: uuid
  note: note_obj_rel_insert_input
  note_id: uuid
}

"""aggregate max on columns"""
type note_goal_max_fields {
  goal_id: uuid
  id: uuid
  note_id: uuid
}

"""
order by max() on columns of table "note_goal"
"""
input note_goal_max_order_by {
  goal_id: order_by
  id: order_by
  note_id: order_by
}

"""aggregate min on columns"""
type note_goal_min_fields {
  goal_id: uuid
  id: uuid
  note_id: uuid
}

"""
order by min() on columns of table "note_goal"
"""
input note_goal_min_order_by {
  goal_id: order_by
  id: order_by
  note_id: order_by
}

"""
response of any mutation on the table "note_goal"
"""
type note_goal_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [note_goal!]!
}

"""
on_conflict condition type for table "note_goal"
"""
input note_goal_on_conflict {
  constraint: note_goal_constraint!
  update_columns: [note_goal_update_column!]! = []
  where: note_goal_bool_exp
}

"""Ordering options when selecting data from "note_goal"."""
input note_goal_order_by {
  goal: goal_order_by
  goal_id: order_by
  id: order_by
  note: note_order_by
  note_id: order_by
}

"""primary key columns input for table: note_goal"""
input note_goal_pk_columns_input {
  id: uuid!
}

"""
select columns of table "note_goal"
"""
enum note_goal_select_column {
  """column name"""
  goal_id

  """column name"""
  id

  """column name"""
  note_id
}

"""
input type for updating data in table "note_goal"
"""
input note_goal_set_input {
  goal_id: uuid
  id: uuid
  note_id: uuid
}

"""
update columns of table "note_goal"
"""
enum note_goal_update_column {
  """column name"""
  goal_id

  """column name"""
  id

  """column name"""
  note_id
}

input note_goal_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: note_goal_set_input
  where: note_goal_bool_exp!
}

"""
columns and relationships of "note_goal_view"
"""
type note_goal_view {
  archived: Boolean
  created_at: timestamptz
  description: String
  note_id: uuid
  progress: Int
  rank: Int
  status: String
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
aggregated selection of "note_goal_view"
"""
type note_goal_view_aggregate {
  aggregate: note_goal_view_aggregate_fields
  nodes: [note_goal_view!]!
}

"""
aggregate fields of "note_goal_view"
"""
type note_goal_view_aggregate_fields {
  avg: note_goal_view_avg_fields
  count(columns: [note_goal_view_select_column!], distinct: Boolean): Int!
  max: note_goal_view_max_fields
  min: note_goal_view_min_fields
  stddev: note_goal_view_stddev_fields
  stddev_pop: note_goal_view_stddev_pop_fields
  stddev_samp: note_goal_view_stddev_samp_fields
  sum: note_goal_view_sum_fields
  var_pop: note_goal_view_var_pop_fields
  var_samp: note_goal_view_var_samp_fields
  variance: note_goal_view_variance_fields
}

"""
order by aggregate values of table "note_goal_view"
"""
input note_goal_view_aggregate_order_by {
  avg: note_goal_view_avg_order_by
  count: order_by
  max: note_goal_view_max_order_by
  min: note_goal_view_min_order_by
  stddev: note_goal_view_stddev_order_by
  stddev_pop: note_goal_view_stddev_pop_order_by
  stddev_samp: note_goal_view_stddev_samp_order_by
  sum: note_goal_view_sum_order_by
  var_pop: note_goal_view_var_pop_order_by
  var_samp: note_goal_view_var_samp_order_by
  variance: note_goal_view_variance_order_by
}

"""
input type for inserting array relation for remote table "note_goal_view"
"""
input note_goal_view_arr_rel_insert_input {
  data: [note_goal_view_insert_input!]!
}

"""aggregate avg on columns"""
type note_goal_view_avg_fields {
  progress: Float
  rank: Float
}

"""
order by avg() on columns of table "note_goal_view"
"""
input note_goal_view_avg_order_by {
  progress: order_by
  rank: order_by
}

"""
Boolean expression to filter rows from the table "note_goal_view". All fields are combined with a logical 'AND'.
"""
input note_goal_view_bool_exp {
  _and: [note_goal_view_bool_exp!]
  _not: note_goal_view_bool_exp
  _or: [note_goal_view_bool_exp!]
  archived: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  note_id: uuid_comparison_exp
  progress: Int_comparison_exp
  rank: Int_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
input type for inserting data into table "note_goal_view"
"""
input note_goal_view_insert_input {
  archived: Boolean
  created_at: timestamptz
  description: String
  id: uuid
  note_id: uuid
  progress: Int
  rank: Int
  status: String
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type note_goal_view_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  note_id: uuid
  progress: Int
  rank: Int
  status: String
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "note_goal_view"
"""
input note_goal_view_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  note_id: order_by
  progress: order_by
  rank: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type note_goal_view_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  note_id: uuid
  progress: Int
  rank: Int
  status: String
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "note_goal_view"
"""
input note_goal_view_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  note_id: order_by
  progress: order_by
  rank: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""Ordering options when selecting data from "note_goal_view"."""
input note_goal_view_order_by {
  archived: order_by
  created_at: order_by
  description: order_by
  id: order_by
  note_id: order_by
  progress: order_by
  rank: order_by
  status: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""
select columns of table "note_goal_view"
"""
enum note_goal_view_select_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  note_id

  """column name"""
  progress

  """column name"""
  rank

  """column name"""
  status

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate stddev on columns"""
type note_goal_view_stddev_fields {
  progress: Float
  rank: Float
}

"""
order by stddev() on columns of table "note_goal_view"
"""
input note_goal_view_stddev_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate stddev_pop on columns"""
type note_goal_view_stddev_pop_fields {
  progress: Float
  rank: Float
}

"""
order by stddev_pop() on columns of table "note_goal_view"
"""
input note_goal_view_stddev_pop_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate stddev_samp on columns"""
type note_goal_view_stddev_samp_fields {
  progress: Float
  rank: Float
}

"""
order by stddev_samp() on columns of table "note_goal_view"
"""
input note_goal_view_stddev_samp_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate sum on columns"""
type note_goal_view_sum_fields {
  progress: Int
  rank: Int
}

"""
order by sum() on columns of table "note_goal_view"
"""
input note_goal_view_sum_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate var_pop on columns"""
type note_goal_view_var_pop_fields {
  progress: Float
  rank: Float
}

"""
order by var_pop() on columns of table "note_goal_view"
"""
input note_goal_view_var_pop_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate var_samp on columns"""
type note_goal_view_var_samp_fields {
  progress: Float
  rank: Float
}

"""
order by var_samp() on columns of table "note_goal_view"
"""
input note_goal_view_var_samp_order_by {
  progress: order_by
  rank: order_by
}

"""aggregate variance on columns"""
type note_goal_view_variance_fields {
  progress: Float
  rank: Float
}

"""
order by variance() on columns of table "note_goal_view"
"""
input note_goal_view_variance_order_by {
  progress: order_by
  rank: order_by
}

"""
input type for incrementing numeric columns in table "note"
"""
input note_inc_input {
  version: Int
}

"""
input type for inserting data into table "note"
"""
input note_insert_input {
  archived: Boolean
  body: String
  created_at: timestamptz
  date: date
  file: file_data_obj_rel_insert_input
  goals: note_goal_view_arr_rel_insert_input
  id: uuid
  note_goal: note_goal_arr_rel_insert_input
  pinned: Boolean
  title: String
  updated_at: timestamptz
  user_id: uuid
  version: Int
}

"""aggregate max on columns"""
type note_max_fields {
  body: String
  created_at: timestamptz
  date: date
  id: uuid
  title: String
  updated_at: timestamptz
  user_id: uuid
  version: Int
}

"""
order by max() on columns of table "note"
"""
input note_max_order_by {
  body: order_by
  created_at: order_by
  date: order_by
  id: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
  version: order_by
}

"""aggregate min on columns"""
type note_min_fields {
  body: String
  created_at: timestamptz
  date: date
  id: uuid
  title: String
  updated_at: timestamptz
  user_id: uuid
  version: Int
}

"""
order by min() on columns of table "note"
"""
input note_min_order_by {
  body: order_by
  created_at: order_by
  date: order_by
  id: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
  version: order_by
}

"""
response of any mutation on the table "note"
"""
type note_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [note!]!
}

"""
input type for inserting object relation for remote table "note"
"""
input note_obj_rel_insert_input {
  data: note_insert_input!

  """upsert condition"""
  on_conflict: note_on_conflict
}

"""
on_conflict condition type for table "note"
"""
input note_on_conflict {
  constraint: note_constraint!
  update_columns: [note_update_column!]! = []
  where: note_bool_exp
}

"""Ordering options when selecting data from "note"."""
input note_order_by {
  archived: order_by
  body: order_by
  created_at: order_by
  date: order_by
  file: file_data_order_by
  goals_aggregate: note_goal_view_aggregate_order_by
  id: order_by
  note_goal_aggregate: note_goal_aggregate_order_by
  pinned: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
  version: order_by
}

"""primary key columns input for table: note"""
input note_pk_columns_input {
  id: uuid!
}

"""
select columns of table "note"
"""
enum note_select_column {
  """column name"""
  archived

  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  pinned

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "note"
"""
input note_set_input {
  archived: Boolean
  body: String
  created_at: timestamptz
  date: date
  id: uuid
  pinned: Boolean
  title: String
  updated_at: timestamptz
  user_id: uuid
  version: Int
}

"""aggregate stddev on columns"""
type note_stddev_fields {
  version: Float
}

"""
order by stddev() on columns of table "note"
"""
input note_stddev_order_by {
  version: order_by
}

"""aggregate stddev_pop on columns"""
type note_stddev_pop_fields {
  version: Float
}

"""
order by stddev_pop() on columns of table "note"
"""
input note_stddev_pop_order_by {
  version: order_by
}

"""aggregate stddev_samp on columns"""
type note_stddev_samp_fields {
  version: Float
}

"""
order by stddev_samp() on columns of table "note"
"""
input note_stddev_samp_order_by {
  version: order_by
}

"""aggregate sum on columns"""
type note_sum_fields {
  version: Int
}

"""
order by sum() on columns of table "note"
"""
input note_sum_order_by {
  version: order_by
}

"""
update columns of table "note"
"""
enum note_update_column {
  """column name"""
  archived

  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  pinned

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  version
}

input note_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: note_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: note_set_input
  where: note_bool_exp!
}

"""aggregate var_pop on columns"""
type note_var_pop_fields {
  version: Float
}

"""
order by var_pop() on columns of table "note"
"""
input note_var_pop_order_by {
  version: order_by
}

"""aggregate var_samp on columns"""
type note_var_samp_fields {
  version: Float
}

"""
order by var_samp() on columns of table "note"
"""
input note_var_samp_order_by {
  version: order_by
}

"""aggregate variance on columns"""
type note_variance_fields {
  version: Float
}

"""
order by variance() on columns of table "note"
"""
input note_variance_order_by {
  version: order_by
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "activity"
  """
  activity_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [activity_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [activity_order_by!]

    """filter the rows returned"""
    where: activity_bool_exp
  ): activityConnection!

  """
  fetch data from the table: "enckey"
  """
  enckey_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [enckey_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [enckey_order_by!]

    """filter the rows returned"""
    where: enckey_bool_exp
  ): enckeyConnection!

  """
  fetch data from the table: "file_data"
  """
  file_data_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [file_data_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [file_data_order_by!]

    """filter the rows returned"""
    where: file_data_bool_exp
  ): file_dataConnection!

  """
  fetch data from the table: "goal"
  """
  goal_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [goal_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [goal_order_by!]

    """filter the rows returned"""
    where: goal_bool_exp
  ): goalConnection!

  """
  fetch data from the table: "memouser"
  """
  memouser_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [memouser_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [memouser_order_by!]

    """filter the rows returned"""
    where: memouser_bool_exp
  ): memouserConnection!
  node(
    """A globally unique id"""
    id: ID!
  ): Node

  """
  fetch data from the table: "note"
  """
  note_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [note_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [note_order_by!]

    """filter the rows returned"""
    where: note_bool_exp
  ): noteConnection!

  """An array relationship connection"""
  note_goal_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [note_goal_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [note_goal_order_by!]

    """filter the rows returned"""
    where: note_goal_bool_exp
  ): note_goalConnection!

  """
  fetch data from the table: "status_simple"
  """
  status_simple_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [status_simple_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [status_simple_order_by!]

    """filter the rows returned"""
    where: status_simple_bool_exp
  ): status_simpleConnection!

  """
  fetch data from the table: "todo"
  """
  todo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [todo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [todo_order_by!]

    """filter the rows returned"""
    where: todo_bool_exp
  ): todoConnection!
}

"""
columns and relationships of "status_simple"
"""
type status_simple implements Node {
  id: ID!
  value: String!
}

"""
A Relay connection object on "status_simple"
"""
type status_simpleConnection {
  edges: [status_simpleEdge!]!
  pageInfo: PageInfo!
}

type status_simpleEdge {
  cursor: String!
  node: status_simple!
}

"""
Boolean expression to filter rows from the table "status_simple". All fields are combined with a logical 'AND'.
"""
input status_simple_bool_exp {
  _and: [status_simple_bool_exp!]
  _not: status_simple_bool_exp
  _or: [status_simple_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "status_simple"
"""
enum status_simple_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  goal_status_pkey
}

enum status_simple_enum {
  active
  inactive
  onhold
}

"""
Boolean expression to compare columns of type "status_simple_enum". All fields are combined with logical 'AND'.
"""
input status_simple_enum_comparison_exp {
  _eq: status_simple_enum
  _in: [status_simple_enum!]
  _is_null: Boolean
  _neq: status_simple_enum
  _nin: [status_simple_enum!]
}

"""
input type for inserting data into table "status_simple"
"""
input status_simple_insert_input {
  value: String
}

"""
response of any mutation on the table "status_simple"
"""
type status_simple_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [status_simple!]!
}

"""
on_conflict condition type for table "status_simple"
"""
input status_simple_on_conflict {
  constraint: status_simple_constraint!
  update_columns: [status_simple_update_column!]! = []
  where: status_simple_bool_exp
}

"""Ordering options when selecting data from "status_simple"."""
input status_simple_order_by {
  value: order_by
}

"""primary key columns input for table: status_simple"""
input status_simple_pk_columns_input {
  value: String!
}

"""
select columns of table "status_simple"
"""
enum status_simple_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "status_simple"
"""
input status_simple_set_input {
  value: String
}

"""
update columns of table "status_simple"
"""
enum status_simple_update_column {
  """column name"""
  value
}

input status_simple_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: status_simple_set_input
  where: status_simple_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "activity"
  """
  activity_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [activity_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [activity_order_by!]

    """filter the rows returned"""
    where: activity_bool_exp
  ): activityConnection!

  """
  fetch data from the table: "enckey"
  """
  enckey_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [enckey_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [enckey_order_by!]

    """filter the rows returned"""
    where: enckey_bool_exp
  ): enckeyConnection!

  """
  fetch data from the table: "file_data"
  """
  file_data_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [file_data_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [file_data_order_by!]

    """filter the rows returned"""
    where: file_data_bool_exp
  ): file_dataConnection!

  """
  fetch data from the table: "goal"
  """
  goal_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [goal_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [goal_order_by!]

    """filter the rows returned"""
    where: goal_bool_exp
  ): goalConnection!

  """
  fetch data from the table: "memouser"
  """
  memouser_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [memouser_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [memouser_order_by!]

    """filter the rows returned"""
    where: memouser_bool_exp
  ): memouserConnection!
  node(
    """A globally unique id"""
    id: ID!
  ): Node

  """
  fetch data from the table: "note"
  """
  note_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [note_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [note_order_by!]

    """filter the rows returned"""
    where: note_bool_exp
  ): noteConnection!

  """An array relationship connection"""
  note_goal_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [note_goal_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [note_goal_order_by!]

    """filter the rows returned"""
    where: note_goal_bool_exp
  ): note_goalConnection!

  """
  fetch data from the table: "status_simple"
  """
  status_simple_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [status_simple_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [status_simple_order_by!]

    """filter the rows returned"""
    where: status_simple_bool_exp
  ): status_simpleConnection!

  """
  fetch data from the table: "todo"
  """
  todo_connection(
    after: String
    before: String

    """distinct select on columns"""
    distinct_on: [todo_select_column!]
    first: Int
    last: Int

    """sort the rows by one or more columns"""
    order_by: [todo_order_by!]

    """filter the rows returned"""
    where: todo_bool_exp
  ): todoConnection!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "todo"
"""
type todo implements Node {
  archived: Boolean!
  created_at: timestamptz!
  id: ID!
  rank: Int!
  title: String!
  updated_at: timestamptz!
  user_id: uuid!
}

"""
A Relay connection object on "todo"
"""
type todoConnection {
  edges: [todoEdge!]!
  pageInfo: PageInfo!
}

type todoEdge {
  cursor: String!
  node: todo!
}

"""
aggregated selection of "todo"
"""
type todo_aggregate {
  aggregate: todo_aggregate_fields
  nodes: [todo!]!
}

"""
aggregate fields of "todo"
"""
type todo_aggregate_fields {
  avg: todo_avg_fields
  count(columns: [todo_select_column!], distinct: Boolean): Int!
  max: todo_max_fields
  min: todo_min_fields
  stddev: todo_stddev_fields
  stddev_pop: todo_stddev_pop_fields
  stddev_samp: todo_stddev_samp_fields
  sum: todo_sum_fields
  var_pop: todo_var_pop_fields
  var_samp: todo_var_samp_fields
  variance: todo_variance_fields
}

"""
order by aggregate values of table "todo"
"""
input todo_aggregate_order_by {
  avg: todo_avg_order_by
  count: order_by
  max: todo_max_order_by
  min: todo_min_order_by
  stddev: todo_stddev_order_by
  stddev_pop: todo_stddev_pop_order_by
  stddev_samp: todo_stddev_samp_order_by
  sum: todo_sum_order_by
  var_pop: todo_var_pop_order_by
  var_samp: todo_var_samp_order_by
  variance: todo_variance_order_by
}

"""
input type for inserting array relation for remote table "todo"
"""
input todo_arr_rel_insert_input {
  data: [todo_insert_input!]!

  """upsert condition"""
  on_conflict: todo_on_conflict
}

"""aggregate avg on columns"""
type todo_avg_fields {
  rank: Float
}

"""
order by avg() on columns of table "todo"
"""
input todo_avg_order_by {
  rank: order_by
}

"""
Boolean expression to filter rows from the table "todo". All fields are combined with a logical 'AND'.
"""
input todo_bool_exp {
  _and: [todo_bool_exp!]
  _not: todo_bool_exp
  _or: [todo_bool_exp!]
  archived: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  rank: Int_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "todo"
"""
enum todo_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  todo_pkey
}

"""
input type for incrementing numeric columns in table "todo"
"""
input todo_inc_input {
  rank: Int
}

"""
input type for inserting data into table "todo"
"""
input todo_insert_input {
  archived: Boolean
  created_at: timestamptz
  id: uuid
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type todo_max_fields {
  created_at: timestamptz
  id: uuid
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "todo"
"""
input todo_max_order_by {
  created_at: order_by
  id: order_by
  rank: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type todo_min_fields {
  created_at: timestamptz
  id: uuid
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "todo"
"""
input todo_min_order_by {
  created_at: order_by
  id: order_by
  rank: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "todo"
"""
type todo_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [todo!]!
}

"""
on_conflict condition type for table "todo"
"""
input todo_on_conflict {
  constraint: todo_constraint!
  update_columns: [todo_update_column!]! = []
  where: todo_bool_exp
}

"""Ordering options when selecting data from "todo"."""
input todo_order_by {
  archived: order_by
  created_at: order_by
  id: order_by
  rank: order_by
  title: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: todo"""
input todo_pk_columns_input {
  id: uuid!
}

"""
select columns of table "todo"
"""
enum todo_select_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  rank

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "todo"
"""
input todo_set_input {
  archived: Boolean
  created_at: timestamptz
  id: uuid
  rank: Int
  title: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type todo_stddev_fields {
  rank: Float
}

"""
order by stddev() on columns of table "todo"
"""
input todo_stddev_order_by {
  rank: order_by
}

"""aggregate stddev_pop on columns"""
type todo_stddev_pop_fields {
  rank: Float
}

"""
order by stddev_pop() on columns of table "todo"
"""
input todo_stddev_pop_order_by {
  rank: order_by
}

"""aggregate stddev_samp on columns"""
type todo_stddev_samp_fields {
  rank: Float
}

"""
order by stddev_samp() on columns of table "todo"
"""
input todo_stddev_samp_order_by {
  rank: order_by
}

"""aggregate sum on columns"""
type todo_sum_fields {
  rank: Int
}

"""
order by sum() on columns of table "todo"
"""
input todo_sum_order_by {
  rank: order_by
}

"""
update columns of table "todo"
"""
enum todo_update_column {
  """column name"""
  archived

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  rank

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  user_id
}

input todo_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: todo_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: todo_set_input
  where: todo_bool_exp!
}

"""aggregate var_pop on columns"""
type todo_var_pop_fields {
  rank: Float
}

"""
order by var_pop() on columns of table "todo"
"""
input todo_var_pop_order_by {
  rank: order_by
}

"""aggregate var_samp on columns"""
type todo_var_samp_fields {
  rank: Float
}

"""
order by var_samp() on columns of table "todo"
"""
input todo_var_samp_order_by {
  rank: order_by
}

"""aggregate variance on columns"""
type todo_variance_fields {
  rank: Float
}

"""
order by variance() on columns of table "todo"
"""
input todo_variance_order_by {
  rank: order_by
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

